= Diagrams As Rules

== Introduction

PlantUML supports a several types diagrams that are based on entities and relationships, e.g.
class diagrams or component diagrams.

The elements of such diagrams are interpreted as graph patterns and translated into Cypher queries.

=== Nodes

- Groups and entities are interpreted as nodes
- Stereotypes are used as labels, e.g. `\<<Type>>`
- A stereotype may start with a modifier `+` indicating that a label shall be added, e.g. `\<<+Entity>>`
- The description of a node may contain an alias and a filter, e.g. `a {name: 'a'}`, both are optional
- If an alias is specified then it will be returned by the query

.Example: Match nodes by label and attribute and add a label
----
[root {name:"root"}] as r <<Package>> <<+Root>>
----
- Filter for nodes labeled with `Package` and a property `name` with the value `root`
- Add a label `Root` to matching nodes
- Return the matching nodes as `root`

=== Relationships

- The description of a relationship may contain a modifier, an alias, a type and a filter, e.g. `+d1:DEFINES_DEPENDENCY`
- If the modifier `+` is provided a new relation of the given type is created, otherwise the relation is used for filtering

.Example: Match a relation
----
r -down-> a : :CONTAINS
----
- Filter for relations of type `CONTAINS`

.Example: Create a new relation
----
b -right-> a : +d1:DEFINES_DEPENDENCY
----
- Add a relationship of type `DEFINES_DEPENDENCY` between nodes `b` and `a`
- Return the created relationships as `d1`

== Examples

=== Component Diagrams

The following component diagram demonstrates...

- matching of Java packages
- and adding relationships

...for specifying the defined dependencies of a layered architecture:

[[plantuml-rule:ComponentDiagram]]
[plantuml,ComponentDiagram,role=concept]
.The root package contains the components `A`, `B` and `C` with defined dependencies between them.
----
@startuml
skinparam componentStyle uml2

[root {name:"root"}] as r <<Package>> <<+Root>>

[a {name:"a"}] as a <<Package>> <<+Module>>
[b {name:"b"}] as b <<Package>> <<+Module>>
[c {name:"c"}] as c <<Package>> <<+Module>>

r -down-> a : :CONTAINS
r -down-> b : :CONTAINS
r -down-> c : :CONTAINS

b -right-> a : +d1:DEFINES_DEPENDENCY
c -left->  a : +d2:DEFINES_DEPENDENCY

@enduml
----

The rule above...

- Matches for a package named `root` and adds a label `Root` to it
- Matches contained packages named `a`, `b`, `c` and adds a label `Module` to them
- Creates relationships of type `DEFINES_DEPENDENCY` between `b` and `a` as well as between `c` and `a`
- Returns the nodes with the aliases `root`, `a`, `b`, `c` as well as the created relationships `d1` and `d2`. The aliases are defined in the description of a node or relationship.

The example will be translated into a cypher query like this:

[source,cypher]
----
MATCH
  (root:Package{name:"root"}),
  (a:Package{name:"a"}),
  (b:Package{name:"b"}),
  (c:Package{name:"c"}),
  (root)-[:CONTAINS]->(a),
  (root)-[:CONTAINS]->(b),
  (root)-[:CONTAINS]->(c)
SET
  root:Root
SET
  a:Module
SET
  b:Module
SET
  c:Module
MERGE
  (b)-[d1:DEFINES_DEPENDENCY]->(a)
MERGE
  (c)-[d2:DEFINES_DEPENDENCY]->(a)
RETURN
  root, a, b, c, d1, d2
----

=== Component Diagram Without Aliases

The same diagram may be specified but without any alias in the descriptions of nodes and relationships.

[[plantuml-rule:ComponentDiagramWithoutAliases]]
[plantuml,ComponentDiagramWithoutAliases,role=concept]
.The root package contains the components `A`, `B` and `C` with defined dependencies between them.
----
@startuml
skinparam componentStyle uml2

[{name:"root"}] as r <<Package>> <<+Root>>

[{name:"a"}] as a <<Package>> <<+Module>>
[{name:"b"}] as b <<Package>> <<+Module>>
[{name:"c"}] as c <<Package>> <<+Module>>

r -down-> a : :CONTAINS
r -down-> b : :CONTAINS
r -down-> c : :CONTAINS

b -right-> a : +:DEFINES_DEPENDENCY
c -left->  a : +:DEFINES_DEPENDENCY

@enduml
----

In this case the generated Cypher query will just return the count of results:

[source,cypher]
----
MATCH
  (cl0100:Package{name:"root"}),
  (cl0101:Package{name:"a"}),
  (cl0102:Package{name:"b"}),
  (cl0103:Package{name:"c"}),
  (cl0100)-[:CONTAINS]->(cl0101),
  (cl0100)-[:CONTAINS]->(cl0102),
  (cl0100)-[:CONTAINS]->(cl0103)
SET
  cl0100:Root
SET
  cl0101:Module
SET
  cl0102:Module
SET
  cl0103:Module
MERGE
  (cl0102)-[:DEFINES_DEPENDENCY]->(cl0101)
MERGE
  (cl0103)-[:DEFINES_DEPENDENCY]->(cl0101)
RETURN
  count(*) as Count
----

NOTE: The aliases used within the query (e.g. `cl0100`) are generated and there's no guarantee about the used format.

=== Component Diagram With Folders

It is possible to use folders which are also interpreted as nodes:

[[plantuml-rule:NestedPackageDiagram]]
[plantuml,NestedPackageDiagram,role=concept]
.The package named "root" is labeled with `Root` and contains packages representing the layers of the application. They are labeled with `Layer`.
----
@startuml
skinparam componentStyle uml2

package "{name:'root'}" as root <<Package>> <<+Root>> {
  package "layer" as layer <<Package>> <<+Layer>>
}

root -> layer : :CONTAINS

@enduml
----

The resulting query will be as follows:

[source,cypher]
----
MATCH
  (cl0069:Package{name:'root'}),
  (layer:Package),
  (cl0069)-[:CONTAINS]->(layer)
SET
  cl0069:Root
SET
  layer:Layer
RETURN
  layer
----

[[plantuml-rule:ClassDiagram]]
[plantuml,ClassDiagram,role=concept]
.A class diagram
----
@startuml

skinparam componentStyle uml2

class "{name:"AbstractEntity"}" as abstractEntity <<Type>>
class "entity" as entity <<Class>> <<+Entity>>

entity -up-|> abstractEntity  : :EXTENDS*

@enduml
----
